---
layout: post
title: "Spring源码分析——BeanPostProcessor"
date: 2019-3-16
tag: JavaEE

---

[TOC]

###  Bean生命周期——BeanPostProcessor

容器管理bean的生命周期，创建——初始化——销毁

**创建：**

单实例是在容器初始化的时候创建对象；

多实例是在获取对象的时候创建对象；

**销毁:**

单实例，容器关闭的时候；

多实例，容器不会管理这个bean，容器不会调用销毁方法

#### 生命周期流程图

spring bean的完整生命周期包括容器创建开始，一直到容器销毁bean

![bean生命周期流程](https://raw.githubusercontent.com/yuanyi0510/yuanyi0510.github.io/master/images/bolg_images/spring%E6%BA%90%E7%A0%81/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B.jpg)

- 如果BeanFactory装配了org.springframework.beans.factory.config.BeanPostProcessor后处理器，将调用BeanPostProcessor的Object PostProcessBeforeInitialization(Object bean,String beanName)接口方法对Bean进行加工操作。其中入参bean是当前正在处理的Bean，而beanName是当前Bean的配置名，返回的对象为加工处理后的Bean。用户可以使用该方法对某些Bean进行特殊的处理，甚至改变Bean的行为，BeanPostProcessor在[spring](http://lib.csdn.net/base/javaee)框架中占有重要的地位，为容器提供对Bean进行后续加工处理的切入点，Spring容器所提供的各种“神奇功能”（如AOP，动态代理等）都通过BeanPostProcessor实施；

- 如果Bean的作用范围为scope=“prototype”，将Bean返回给调用者，调用者负责Bean后续生命的管理，Spring不再管理这个Bean的生命周期。如果作用范围设置为scope=“Singleton”，则将Bean放入到SpringIoC容器的缓存池中，并将Bean引用返回给调用者，Spring继续对这些Bean进行后续的生命管理；


- 对于scope=“singleton”的Bean，当容器关闭时，将触发Spring对Bean的后续生命周期的管理工作，首先如果Bean实现了DisposableBean接口，则将调用接口的afterPropertiesSet()方法，可以在此编写释放资源，记录日志等操作，

  如果通过<bean>的destroy-method属性执行了Bean的销毁方法，Spring将执行Bean的这个方法，完成Bean资源的释放等操作


Bean的完整生命周期从Spring容器着手实例化Bean开始，直到最终销毁Bean，这当中经过了许多关键点，各个关键点都涉及特定的方法调用，可以将这些方法大致划分为三类：

1. Bean自身的方法：如调用Bean构造函数实例化Bean，调用Setter设置Bean 的属性值以及 init-method所指定的方法；
2. Bean级生命周期接口方法：如BeanNameAware、BeanFactoryAware、InitializingBean和 DisposaleBean，这些接口方法由Bean类直接实现；

3. 容器级生命周期接口方法：由InstantiationAwareBeanPostProcessor和BeanPostProcessor这两个接口实现的步骤，一般称它们的实现类为“后置处理器”。后置处理器接口一般不由Bean本身实现，它们独立于Bean， 实现类以容器附加装置的形式注册到Spring容器中并通过接口反射为Spring容器预先识别。当Spring容器创建任何Bean的时候，这些后处理器都会发生作用，所以这些后处理器的影响是全局性的。当然，用户可以通过合理地编写后处理器，让其仅对感兴趣的Bean进行加工处理。


#### 源码分析

在bean的生命周期中可以使用后置处理器**BeanPostProcessor**在对象初始化化前后添加一些逻辑，这里初始化方法是指在配置文件中配置init-method，或者实现了InitializingBean接口的afterPropertiesSet方法,注意不包括@PostConstruct这种初始化方式。可以看源码AbstractAutowireCapableBeanFactory类中的invokeInitMethods方法。

ApplicationContext容器会自动检测Spring配置文件中那些bean所对应的Java类实现了BeanPostProcessor接口，并用addBeanPostProcessor() 自动把它们注册为后置处理器。在创建bean过程中调用它们，所以部署一个后置处理器跟普通的bean没有什么太大区别。

在后置处理器注册到容器中之后，会在AnnotationConfigApplicationContext的构造方法中调用refresh（）方法

```java
@Override
    public void refresh() throws BeansException, IllegalStateException {
        synchronized (this.startupShutdownMonitor) {
            // Prepare this context for refreshing.
            prepareRefresh();

            // Tell the subclass to refresh the internal bean factory.
            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

            // Prepare the bean factory for use in this context.
            prepareBeanFactory(beanFactory);

            try {
                // Allows post-processing of the bean factory in context subclasses.
                postProcessBeanFactory(beanFactory);

                // Invoke factory processors registered as beans in the context.
                invokeBeanFactoryPostProcessors(beanFactory);
　　　　　　　　　 //发现注册bean后置处理器，在这个方法中进行　
                // Register bean processors that intercept bean creation.
                registerBeanPostProcessors(beanFactory);

                // Initialize message source for this context.
                initMessageSource();

                // Initialize event multicaster for this context.
                initApplicationEventMulticaster();

                // Initialize other special beans in specific context subclasses.
                onRefresh();

                // Check for listener beans and register them.
                registerListeners();

                // Instantiate all remaining (non-lazy-init) singletons.
                finishBeanFactoryInitialization(beanFactory);

                // Last step: publish corresponding event.
                finishRefresh();
            }

            catch (BeansException ex) {
                if (logger.isWarnEnabled()) {
                    logger.warn("Exception encountered during context initialization - " +
                            "cancelling refresh attempt: " + ex);
                }

                // Destroy already created singletons to avoid dangling resources.
                destroyBeans();

                // Reset 'active' flag.
                cancelRefresh(ex);

                // Propagate exception to caller.
                throw ex;
            }

            finally {
                // Reset common introspection caches in Spring's core, since we
                // might not ever need metadata for singleton beans anymore...
                resetCommonCaches();
            }
        }
    }
```

后置处理器生效的地方，进入AbstractAutowireCapableBeanFactory类中的initializeBean方法

```java
protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) {
        if (System.getSecurityManager() != null) {
            AccessController.doPrivileged(new PrivilegedAction<Object>() {
                @Override
                public Object run() {
                    invokeAwareMethods(beanName, bean);
                    return null;
                }
            }, getAccessControlContext());
        }
        else {
            invokeAwareMethods(beanName, bean);
        }
　　　　 
        Object wrappedBean = bean;
        //后置处理器的postProcessBeforeInitialization方法
   //这个是后置处理器的方法，其实@PostConstruct是在CommonAnnotationBeanPostProcessor后置处理器的父类InitDestroyAnnotationBeanPostProcessor中实现的，
            //也就是说@PostConstruct是由后置处理器来处理实现的，进入该方法
        if (mbd == null || !mbd.isSynthetic()) {
            wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
        }
　　　　　//调用初始化方法有:init-method,实现了InitializingBean接口的方法　
        try {
            invokeInitMethods(beanName, wrappedBean, mbd);
        }
        catch (Throwable ex) {
            throw new BeanCreationException(
                    (mbd != null ? mbd.getResourceDescription() : null),
                    beanName, "Invocation of init method failed", ex);
        }
        //后置处理器的postProcessAfterInitialization方法
        if (mbd == null || !mbd.isSynthetic()) {
            wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
        }
        return wrappedBean;
    }
```

进入applyBeanPostProcessorsBeforeInitialization方法，看看如何实现，在初始化之前添加逻辑。循环的遍历所有的后置处理器，一旦postProcessBeforeInitialization方法返回null跳出循环

```java
public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)
            throws BeansException {

        Object result = existingBean;
        for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
　　　　　　　//在循环中会发现一个类 CommonAnnotationBeanPostProcessor，然后进入其父类InitDestroyAnnotationBeanPostProcessor的postProcessBeforeInitialization该方法 进入该方法
            result = beanProcessor.postProcessBeforeInitialization(result, beanName);
            if (result == null) {
                return result;
            }
        }
        return result;
    }
```



下面我们再看看postProcessBeforeInitialization方法

```java
 public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        //该类封装着一些通过注解的方式标识的初始化方法和销毁方法，以及相关属性
        LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());
        try {
            //@PostConstrutct注解就是在此处生效调用
            metadata.invokeInitMethods(bean, beanName);
        }
        catch (InvocationTargetException ex) {
            throw new BeanCreationException(beanName, "Invocation of init method failed", ex.getTargetException());
        }
        catch (Throwable ex) {
            throw new BeanCreationException(beanName, "Failed to invoke init method", ex);
        }
        return bean;
    }
```







