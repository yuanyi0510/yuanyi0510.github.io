---
layout: post
title: "腾讯-分布式开发"
date: 2019-3-7
tag: 面试总结 
---

### 介绍项目，问了单点登录

[参考博客](https://www.cnblogs.com/lexiaofei/p/7172214.html)

### 为什么项目中使用redis，好处是什么

- 速度快，因为数据存储在内存中
- 支持丰富的数据类型
- redis是单进程单线程：利用队列技术将并发访问变成串行访问，消除传统数据库串行控制的开销
- 可以设置过期时间

### 项目中的用户表如何设计的，采用什么索引

### 进程和线程的区别

进程是资源分配的基本单位。进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。

线程是独立调度的基本单位。一个进程中可以有多个线程，它们共享进程资源。

区别：

Ⅰ 拥有资源

进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

Ⅱ 调度

线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

Ⅲ 系统开销

由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

Ⅳ 通信方面

线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC

### tcp协议

传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。

![首部格式](https://raw.githubusercontent.com/CyC2018/CS-Notes/master/docs/notes/pics/55dc4e84-573d-4c13-a765-52ed1dd251f9.png)



三次握手：

![三次握手](https://raw.githubusercontent.com/CyC2018/CS-Notes/master/docs/notes/pics/e92d0ebc-7d46-413b-aec1-34a39602f787.png)

假设 A 为客户端，B 为服务器端。

- 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。
- A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。
- B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。
- A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。
- B 收到 A 的确认后，连接建立。

**三次握手的原因**

第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

四次挥手：

![](https://raw.githubusercontent.com/CyC2018/CS-Notes/master/docs/notes/pics/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg)

以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。

- A 发送连接释放报文，FIN=1。
- B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。
- 当 B 不再需要连接时，发送连接释放报文，FIN=1。
- A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。
- B 收到 A 的确认后释放连接。

**四次挥手的原因**

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

**可靠传输**：超时重传。如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段

### 在浏览器中输入www.baidu.com点击搜索之后发生了什么？

- 输入网址 一个完整的url包括协议、服务器地址（主机）、端口、路径

- 负责域名查询和域名解析的DNS服务

  - 先从浏览器缓存中找ip
  - 没有的话，从本地hosts文件查找是否有该域名和对应的ip
  - 没有的话再从路由器缓存中查找
  - 如果还是没有，就从本地DNS缓存中找
  - 如果都没有，本地DNS就将请求发至13台根域（根域服务器知识具有13个ip地址，但机器数量却不是13台，因为这些IP地址借助了任波技术，在全球设立这些IP的镜像站点）。跟域服务器收到请求后会判断这个域名（.com）是谁负责的，并返回一个负责该顶级域名服务器的ip。本地dns联系负责.com的这台服务器，如果无法解析，会联系下一级域名服务器，重复上面的动作，直至找到www.baidu.com的主机
  - 注意：从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间的交互查询就是迭代查询

- 应用层 客户端发送http请求报文

  - http请求报文包括：报文首部（请求行+首部字段）、空行、报文主体

  - ```
    请求资源所在服务器
    Host: www.baidu.com
    连接方式：持久连接     HTTP/1.1之前版本默认非持久连接
    Connection: keep-alive
    报文指令：要求所有中间服务器不返回缓存资源
    Pragma: no-cache
    控制缓存的行为：缓存前必须先确认其有效性，防止从缓存中返回过期的资源
    Cache-Control: no-cache
    用户代理可处理的媒体类型
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8   q表示权重从而区分优先级
    http客户端浏览器信息
    User-Agent: Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.87 Safari/537.36
    可接受的内容编码类型
    Accept-Encoding: gzip, deflate, sdch
    可接受的语言
    Accept-Language: zh-CN,zh;q=0.8
    相关信息或标记
    Cookie: BAIDUID=3C67AA3EF6B3347D3AA986CE489268C4:FG=1; BIDUPSID=3C67AA3EF6B3347D3AA986CE489268C4;
    ```

  - 传输层  确保传输报文可靠性的TCP协议[参考博客](https://www.jianshu.com/p/ff36b6ab503e)

    - 建立连接  tcp中所谓的连接，指的是通信双方建立的一个一对一的逻辑关系，让双方都明确对方是自己的通信目标
    - TCP 的可靠连接是靠 seq（ sequence numbers 序列号）来达成的。
    - 确保传输可靠性的方式
      - 校验和
      - 序列号和确认应答（ack）
      - 超时重传  发送方在发送数据后等待一个时间，时间到了没有接收到ack报文，那么对刚才发送的数据进行重新发送
      - 连接管理  三次握手 四次挥手
      - 流量控制  tcp报头信息有个16位字段的窗口大小
      - 拥塞控制 慢开始、拥塞避免、快重传、快恢复

  - 网络层  IP协议查询mac地址  分组

    - ARP协议可以将IP地址解析成mac地址
    - RARP协议可以将mac地址解析成IP地址

  - 数据链路层  封装成帧，透明传输、差错校验CRC

  - 物理层

  - 服务器接收数据并响应请求

  - 页面渲染

    ​

### 数据库的索引，聚合索引如何使用

唯一索引、聚合索引、主键索引



### 死锁，日常生活中遇到的死锁

死锁：A中持有B需要的资源，同时申请B占有的资源

### 有一个很大的数字，达到上亿级别，如何判断有没有存在一个指定的子数字呢？

- 二分查找，将数字分为两类，最高位为0，最高位为1，写入两个文件，然后依次类推。O（logN）
- 分治法：确定一个hash函数，通过hash函数可以将数字划分到1000个文件中，对查找数字也同样使用hash函数求出hash值i，那数要是存在一定在ai中
- 位图法：以32位整型为例，它可以表示数字的个数为2^32.可以申请一个位图，让每个整数对应的位图中的一个bit，这样2^32个数需要的位图的大小为512MB。具体实现的思路为：申请一个512MB的位图，并把所有的位都初始化为0；接着遍历所有的整数，对遍历到的数字，把相应的位置上的bit设置为1.最后判断待查找的数对应的位图上的值是多少，如果是0，那么表示这个数字不存在，如果是1，那么表示这个数字存在。

### A表中有T1 T2 T3，b表中有T2 T3 T4，如何选择a表中t2有的b中t2没有的数据

select a.t2 from a leftjoin b on a.t2=b.t2 where b.t2 is null

### ArrayList

[参考博客](https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%AE%B9%E5%99%A8.md#arraylist)

### 输入四个点判断是否为正方形

四条边相等、对角线相等，且对角线大于四条边

```java

 public boolean isSquare (int p1[],int p2[],int p3[],int p4[]){		
	 int p[][]={{p1[0],p1[1]},{p2[0],p2[1]},{p3[0],p3[1]},{p4[0],p4[1]}};
      int cnt=0;
      int  len[]=new int[6];
      for(int i=0;i<=3;i++){
    	  for(int j=i+1;j<=3;j++){    
          // p[i][0]是第i个点的x坐标;p[j][1]是第j个点的y坐标
       len[cnt++]=(p[i][0]-p[j][0])*(p[i][0]-p[j][0])+(p[i][1]-p[j][1])*(p[i][1]-p[j][1]);
    	  }
     
      }
    //数组排序 最长的是对角线
       Arrays.sort(len);
     //相邻两边相等,对角线相等的四边形是正方形;
       if(len[0]==len[1]&&len[4]==len[5]&&len[4]>len[1]){
    	   return true;
       }
       return false;
	}
}
```

### 对分布式的理解

