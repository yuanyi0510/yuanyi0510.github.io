---
layout: post
title: "数据类型和操作符"
date: 2017-07-13   
tag: JavaSE
---

[TOC]



###  程序概述

​	软件是什么？软件就是用来处理数据的程序。软件可以拆分为两个部分，一个部分是**“数据”**；另一个部分是**'数据处理的逻辑'**。

**程序 = 数据 + 逻辑**

**程序的本质：输入和输出**

**软件设计的本质：解耦**

### 数据类型

Java的两大数据类型：

1. 内置数据类型
2. 引用数据类型

#### 内置数据类型

​	Java提供了八种基本类型，四个整数型，两个浮点型，一种字符类型，还有一种布尔型。

##### 1.byte

- byte数据类型是8位的、有符号的，以二进制补码表示的整数；
- 最小值是-128；
- 最大值是127；
- 默认值是0；
- byte类型在大型数组中使用主要是为了**节约空间**，主要代替整数。因为byte变量占用的空间只有int类型的四分之一；

####      2. short

- short数据类型是16位的、有符号的以二进制补码表示的整数
- 最小值是-2^15
- 最大值是2^15-1
- 一个short是int所占空间的二分之一
- 默认值是0

	#### 	3.int

- int数据类型是32位的、有符号的以二进制补码表示的整数
- 最小值-2^31
- 最大值2^31-1
- 一般整型变量默认为int类型
- 默认值是0

	#### 	4.long

- long数据类型是64位、有符号的以二进制补码表示的整数
- 最小值-2^63
- 最大值2^63-1
- 默认值是0L
- 例子：long a=1000000L
- L理论上不分大小写，但小写容易和1弄混

####		5.float

- float数据类型是单精度、32位的浮点数
- 默认值0.0f
- **浮点数计算**

> [参考博客](https://blog.csdn.net/tercel_zhang/article/details/52537726)	
>
> 根据国际标准IEEE 754，任意一个二进制浮点数V可以表示成下面的形式：![浮点数表示](https://raw.githubusercontent.com/yuanyi0510/yuanyi0510.github.io/master/images/bolg_images/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/1.png)
>
> 举个例子：
>
> 5.0写成二进制就是101.0，相当于1.01*2^2,根据上图得出s=0，M=1.01，E=2。*
>
> -5.0写成二进制就是-101.0，相当于-101.0*2^2。s=1，M=1.01, E=2。IEEE 754规定，对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。![32位](https://raw.githubusercontent.com/yuanyi0510/yuanyi0510.github.io/master/images/bolg_images/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.png)
>
> 对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。![64位](https://raw.githubusercontent.com/yuanyi0510/yuanyi0510.github.io/master/images/bolg_images/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/3.png)
>
> IEEE 754对有效数字M和指数E，还有一些特别规定。
>
> 前面说过，1≤M<2，也就是说，M可以写成1.xxxxxx的形式，其中xxxxxx表示小数部分。**IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。**比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。
>
> 至于指数E，情况就比较复杂。首先，E为一个无符号整数（unsigned int）。这意味着，如果E为8位，它的取值范围为0~255；如果E为11位，它的取值范围为0~2047。但是，我们知道，科学计数法中的E是可以出现负数的，**所以IEEE 754规定，E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。**
>
> 比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。然后，指数E还可以再分成三种情况：
>
> **（1）E不全为0或不全为1。**这时，浮点数就采用上面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。
>
> **（2）E全为0。**这时，浮点数的指数E等于1-127=-126（或者1-1023），有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。
>
> **（3）E全为1。**这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；如果有效数字M不全为0，表示这个数不是一个数（NaN）。
>
> ```java
> 举例：int num=9，为什么0x00000009还原成浮点数就成了0？
>   在32位机器中，num表示为二进制 00000000 00000000 00000000 00001001，16进制：0x00000009
>   符号为s=0，指数E=00000000，M=0000000 00000000 00001001
>   浮点数V=(-1)^0×0.00000000000000000001001×2^(-126)=1.001×2^(-146)
>   显然，V是一个很小的接近于0的正数，所以用十进制小数表示就是0.000000。
> ```
>
> ```Java
> 举例：请问浮点数9.0，如何用二进制表示？还原成十进制又是多少？
> 首先，浮点数9.0等于二进制的1001.0，即1.001×2^3。
> 那么，第一位的符号位s=0，有效数字M等于001后面再加20个0，凑满23位，指数E等于3+127=130，即10000010。
> 所以，写成二进制形式，应该是s+E+M，即0 10000010 001 0000 0000 0000 0000 0000。这个32位的二进制数，还原成十进制，正是1091567616。
> ```

#### 	6.double

- double数据类型是双精度、64位的浮点数
- 浮点数的默认类型是double
- 默认值0.0d

#### 	7.boolean

- Boolean数据类型表示一位的信息，只有两个取值：true|false
- 默认值是false

#### 	8.char

- char类型是一个单一的16位的字符
- 最小值是\u0000（即0）
- 最大值\uffff（即65535）
- char类型可以存储任何字符

#### 引用类型

​	在Java中引用类型类似于c语言中的指针。引用类型指向一个对象，指向对象的变量是引用变量，变量一旦声明类型就不能被改变了。

- 对象、数组都是引用数据类型
- 所有引用类型的默认值都是null
- 一个引用变量可以用来引用任何与之兼容的类型

### Java常量

​	常量在以运行时是不能被修改的。可以使用final关键字来修饰常量。

常量的类型：

1. 整数类型
2. 小数类型
3. 布尔类型
4. 字符类型
5. 字符串类型

---

### 运算符

#### 算术运算符

\* % ++ -- + - *  *

**注意：**

1. 在没有复制或者运算参与的情况下，前++和后++结果是相同的
2. 在有赋值或运算的情况下，前++是自身加1在赋值，后++是先赋值在自身加1

####  赋值运算符

 *= += -= *= %=*

#### 关系运算符

*< >= <= != ==* 

**注意：**

1. 关系运算的结果是布尔型的
2. 可以和算术运算符一起使用

#### 逻辑运算符

*&与 |或 ！非  &&短路与 || 短路或*

**区别：**

1. &，&&：只要条件中有一个为false，则结果为false。&在计算中先计算左边的表达式，不管结果是什么都要计算右边的表达式；而&&，计算出左侧的结果为false就不会计算右侧的表达式了

2. | ，||：只要条件中有一个true，则结果为true。|  先计算左侧的表达式，不管结果为什么都计算右边的表达式；|| 如果左侧的计算结果为true，则不会计算右边的值


#### 位运算符

**例子：**

```java
1. 按位取反
int a=6;	
b=~a
//计算过程
a	0000 0110
   _________________
b   1111 1001	——> -7
  
2.按位与——》两个操作数的位数都为1，结果为1
  int a=3;	int b=2;
  int c=a&b
  //计算过程
    a	0000 0011
    b	0000 0010
    _________________
    c	0000 0010	——> 2
 3. 按位或——》两个数都为0，结果为0
    int a=3;	int b=2;
	int c=a|b
    //计算过程
      a	0000 0011
      b	0000 0010
      ____________
      c	0000 0011	——>3
 4. 异或 两个二进制数比较，相同为0
      int a =1;	int c=a^5;
	//计算过程
	i	0001
    5   0101
    __________
    c	0100	——>4
```

#### 位移运算符

```java
1. << 左移	空出来的低位补0
  int a=0;
  a=a<<3;
//过程
a	0000 1001
左移 0100 1000	——>72
2. >> 右移	空出来的高位，正数补0，负数补1
  int b=4;	b=b>>2;
//过程
b	0000 0100
右移 0000 0001	——>1
3. >>> 无符号右移	空出的高位全部补0
```

#### 三目运算符

格式：条件?条件为true执行的语句：条件为false执行的语句